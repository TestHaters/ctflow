import { DocumentSymbol } from "vscode";
import { vscode } from "./utilities/vscode";
import { useStore } from "./context/store";
import { ButtonNodeCompiler } from "./compilers/cypress/buttonNodeCompiler"
import YAML from 'yaml'
import { VisitPageNodeCompiler } from "./compilers/cypress/VisitPageNode";
import { TextInputNodeCompiler } from "./compilers/cypress/TextInputNode";
import { CheckboxNodeCompiler } from "./compilers/cypress/CheckboxNode";
export class Compiler {

	constructor() {

	}

	static compile(store): string {
		// let buttonNodeCompiler = new ButtonNodeCompiler()
		console.log("COMPILER>COMPILE")

		let compiledText = ""
		let orderNodes = this.buildNodeChain(store)

		console.log(orderNodes)

		orderNodes.forEach(node => {
			let compiler = this.findCompiler(node)
			compiledText += compiler.compile(node) + "\n"
		})

		return this.buildCypressJsFile(compiledText)
	}

	static buildCypressJsFile(compiledText: string) {
		return `
		/// <reference types="cypress" />

		context('Generated By Ctflow', () => {
			it('Demo CtFlow', () => {
				${compiledText}
			})
		})
		`
	}

	static findCompiler(node: any) {
		switch (node.type) {
			case "ButtonNode": {
				return ButtonNodeCompiler
			}
			case "visitNode": {
				return VisitPageNodeCompiler
			}
			case "textInputType": {
				return TextInputNodeCompiler
			}
			case "checkboxNode": {
				return CheckboxNodeCompiler
			}
			default: {
				return ButtonNodeCompiler
			}
		}
	}

	static findRootNode(store: any) {
		for (var nodeId in store.nodes) {
			if (store.nodes[nodeId].type === 'visitNode') {
				return store.nodes[nodeId]
			}
		}
	}

	static findEdgeWithSourceId(sourceId: any, edges: any) {
		for (var edgeId in edges) {
			if (edges[edgeId].source === sourceId) {
				return edges[edgeId]
			}
		}

		return false
	}

	// return array of nodes by order
	static buildNodeChain(store: any): any[] {
		let currentNode = this.findRootNode(store)
		let currentEdge: any;
		let orderedNodes = [currentNode]
		console.log("KIA MAY ONG SAO SANG", store)

		// prevent infinity loop
		for (let counter = 0; counter < store.edges.length; counter++) {
			currentEdge = this.findEdgeWithSourceId(currentNode.id, store.edges)
			console.log(currentEdge)
			currentNode = store.nodes.find((node) => node.id.toString() == currentEdge.target.toString())
			if (!currentNode) { break }
			orderedNodes.push(currentNode)
		}

		return orderedNodes;
	}
}
